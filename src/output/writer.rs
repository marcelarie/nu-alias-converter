use rayon::prelude::*;
use std::{
    fs::File,
    io::{BufWriter, Write},
};

use crate::{
    command::arguments::CliArgs, config::alias_ignore::AliasIgnoreResult,
    syntax_tree::alias::Alias,
};

pub fn process_and_write_aliases(
    aliases: Vec<Alias>,
    alias_ignore_result: AliasIgnoreResult,
    args: &CliArgs,
) {
    let output_file_path = args.output_path.clone();

    let file =
        File::create(&output_file_path).expect("Error creating output file");
    let mut writer = BufWriter::new(file);

    writeln!(
        writer,
        "# Aliases auto generated by nu-alias-converter on {}.\n# Changes to this file will be overwritten.\n",
        chrono::Local::now().format("%Y-%m-%d")
    )
    .expect("Error writing to file");

    let results: Vec<String> = aliases.par_iter().map(|alias| {
        let command_ignores = &alias_ignore_result.command_ignores;
        let should_ignore_alias_name = alias_ignore_result.alias_ignores.contains(&alias.name);

        let matching_cmd = command_ignores
            .iter()
            .find(|cmd| alias.content.contains(*cmd));

        let should_ignore = should_ignore_alias_name || matching_cmd.is_some();

        if alias.is_valid_nushell && !should_ignore {
            format!("alias {} = {}", alias.name, alias.content)
        } else if should_ignore && !args.no_comments {
            if let Some(matching_cmd) = matching_cmd {
                format!(
                "# alias {} = {} # Ignored all alias using '{}' command via .aliasignore",
                alias.name, alias.content, matching_cmd)
            } else {
                format!(
                    "# alias {} = {} # Ignored alias via .aliasignore",
                    alias.name, alias.content
                )
            }
        } else if !args.no_comments {
            format!(
                "# alias {} = {} # Errors: {}",
                alias.name,
                alias.content,
                alias.error_messages.join(", ")
            )
        } else {
            String::new() // Return an empty string if no output is needed
        }
    }).collect();

    // Write the collected results
    for result in results {
        if !result.is_empty() {
            writeln!(writer, "{}", result).expect("Error writing to file");
        }
    }

    writer.flush().expect("Error flushing the buffer");

    println!("Aliases written to {}", output_file_path);
}
